---
title: "Sdeng: the SQL database"
categories:
- "Sdeng"
toc: true
toc_sticky: true
---

## A few considerations

Welcome back! Last time we analyzed and understood the main entities involved in our model. Today we will develop the SQL database that will store the data. The juicy part is definitely coming, so without further ado, let's get started.

The first thing to do is to set up the SQL database. The last time I used SQL, the Coronavirus was only a remote voice from China, so forgive me if my code is not the cleanest.

For the same reason, I will use the SQL dialect I am most comfortable with, which is MySQL. About the topic, I want to make a couple of considerations about the two SQL dialects that I considered, MySQL and SQLite.

As you have probably guessed from the name, SQLite is lightweight and portable. It requires almost no configuration and allows us to be operative within minutes. Yet, it offers little flexibility as far as types are concerned, and it has some performance issues when dealing with bigger databases.

On the other hand, MySQL requires setting up a server, an account, and permissions, thus being more complex. Nonetheless, this complexity has its pros, since it allows us to manage more data types and higher loads.
Luckily for us, switching from one dialect to the other is straightforward, and there are many online tools to help us achieve the goal.

---

Now, an important consideration is due: the goal of a relational database is to store millions of entries and to separate the view from the model.
Consider the table containing the players on the field in every action: an NBA game as more or less 500 actions, in every of each 10 players are on the court. If you consider that NBA regular season alone has 1230 games, this means that for a single season we have more than 5 million rows in this table.

Thus, the database must be efficient. For this purpose, every table will have as primary key an autogenerated numerical id. Of course, this leads to a tradeoff in terms of readability, since it is much harder to understand the entities involved when they are represented by a number.

Nonetheless, we can separate the low level, where we use the numerical id,  from the presentation level, where we display the entity's full details, e.g. the full name for players. This also leads to more complex queries, since we have to join more tables to fetch the correct information. Yet, the advantages that this strategy provides in terms of efficiency make it worthy to use it.

---

Let's dive into the database. I will not go into details on how to install and configure a MySQL server, many people already did that and in a much better way than I would ever be able to do. I suggest this.

Let's start from creating the MySQL database.

```sql
CREATE DATABASE sdeng;
```

I named it Sdeng, but you can name it as you prefer.

From now on, I will assume that you have all permissions on this database. If you haven't, you can add them by logging into MySQL as root and type

```sql
GRANT ALL ON sdeng.* TO 'user'@'localhost';
```

Be sure to replace the database name and username with the ones you chose.

## Tables

### League

```sql
CREATE TABLE leagues (
    id              INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    full_name       VARCHAR(50)          NOT NULL,
    name            VARCHAR(5)           NOT NULL,
    website         TINYTEXT             NULL,
    foundation_year YEAR                 NULL,
    international   TINYINT(1) DEFAULT 0 NULL,
    CONSTRAINT leagues_full_name_uq
        UNIQUE (full_name),
    CONSTRAINT leagues_name_uq
        UNIQUE (name)
)
```

The table is straightforward: the ```TINYINT(1)``` is a boolean value, which we will flag for the Olympics or the World Cup.

### Season

```sql
CREATE TABLE seasons (
    id            INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    starting_year YEAR NOT NULL,
    ending_year   YEAR NOT NULL,
    CONSTRAINT years_uq
        UNIQUE (starting_year, ending_year),
    CONSTRAINT seasons_years_chk
        CHECK (`ending_year` >= `starting_year`)
)
```

This is even more straightforward: notice how the uniqueness of the season is given by the couple ```(starting_year, ending_year)```; thus, we can store data from a League which starts in the spring and ends in autumn. This is frequent in Soccer competitions from Southern Hemisphere, so let's consider the case.

I decided to use a year and not a date because, even if usually a season starts on the first of July and ends on the thirty of June, Covid-19 outbreak or lockouts may change the dates, and it would not make sense to create a different season only for NBA, since it would make much harder to compare leagues.

### Franchise

```sql
CREATE TABLE franchises (
    id              INT UNSIGNED AUTO_INCREMENT
    PRIMARY KEY,
    name            VARCHAR(50)          NOT NULL,
    city            TINYTEXT             NOT NULL,
    country         TINYTEXT             NOT NULL,
    foundation_year YEAR                 NULL,
    national_team   TINYINT(1) DEFAULT 0 NULL,
    CONSTRAINT franchises_name_uq
        UNIQUE (name)
)
```

The considerations for this table are similar to the ones for the leagues' table.

### Players and Managers

Here come the first difficulties: to model the differences between players and managers I decided to use inheritance: the parent table is the "persons" table, where we store personal information.

```sql
CREATE TABLE persons
(
    id            INT UNSIGNED AUTO_INCREMENT
        PRIMARY KEY,
    name          VARCHAR(50)      NOT NULL,
    middle_name   TINYTEXT         NULL,
    surname       VARCHAR(50)      NOT NULL,
    birthday      DATE             NOT NULL,
    birth_city    TINYTEXT         NOT NULL,
    birth_country TINYTEXT         NOT NULL,
    sex           CHAR DEFAULT 'M' NOT NULL,
    nationality_1 TINYTEXT         NULL,
    nationality_2 TINYTEXT         NULL,
    
    CONSTRAINT persons_uq
        UNIQUE (name, surname, birthday, sex)
);
```

We then have a `players` table and a `managers` table: both of them inherit from `persons` using a foreign key.

```sql
CREATE TABLE managers (
    id INT UNSIGNED NOT NULL PRIMARY KEY,
    
    CONSTRAINT managers_persons_fk
        FOREIGN KEY (id) REFERENCES persons(id)
)
```
```sql
CREATE TABLE players (
    id             INT UNSIGNED  NOT NULL PRIMARY KEY,
    main_role      VARCHAR(2)    NOT NULL,
    secondary_role VARCHAR(2)    NULL,
    height         DECIMAL(3, 2) NOT NULL COMMENT 'unit of measure is ms',
    weight         DECIMAL(4, 1) NULL COMMENT 'unit of measure is kgs',
    
    CONSTRAINT players_persons_fk
        FOREIGN KEY (id) REFERENCES persons(id)
);
```

As a general rule I will only use the metrical system since honestly, I find the imperial system gibberish.

### Team

```sql
CREATE TABLE teams (
    id           INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    franchise_id INT UNSIGNED            NOT NULL,
    season_id    INT UNSIGNED            NOT NULL,
    type         VARCHAR(10) DEFAULT 'M' NOT NULL,
    name         TINYTEXT                NOT NULL,
    abbreviation VARCHAR(3)              NOT NULL,
    
    CONSTRAINT teams_uq
        UNIQUE (franchise_id, season_id, type),
    CONSTRAINT teams_franchises_fk
        FOREIGN KEY (franchise_id) REFERENCES franchises(id),
    CONSTRAINT teams_seasons_fk
        FOREIGN KEY (season_id) REFERENCES seasons(id)
)
```
A team is uniquely defined by the triple ("franchise", "season", "type"). This allows franchises not only to have a male (`M`) or female (`F`) team, but also youth teams, which is very common in Europe. For instance this attribute would be `U18M` for the male under-18 team.

### Roster and Staff

To model rosters and staffs I used two tables, one for players and one for managers. They include information about contracts, following the logic that I described in the previous post.

```sql
create table rosters (
    id            int unsigned auto_increment primary key,
    player_id     int unsigned     not null,
    team_id       int unsigned     not null,
    season_id     int unsigned     not null,
    jersey_number tinyint unsigned null,
    amount        decimal(11, 2)   null,
    type          tinytext         null,
    start_date    date             null,
    end_date      date             null,
    
    constraint rosters_players_fk
        foreign key (player_id) references players (id),
    constraint rosters_seasons_fk
        foreign key (season_id) references seasons (id),
    constraint rosters_teams_fk
        foreign key (team_id) references teams (id)
)
```

```sql
create table staffs (
    id         int unsigned auto_increment primary key,
    manager_id int unsigned   not null,
    team_id    int unsigned   not null,
    season_id  int unsigned   not null,
    role       tinytext       not null,
    amount     decimal(11, 2) null,
    type       tinytext       null,
    start_date date           null,
    end_date   date           null,
    
    constraint staffs_players_fk
        foreign key (manager_id) references managers (id),
    constraint staffs_seasons_fk
        foreign key (season_id) references seasons (id),
    constraint staffs_teams_fk
        foreign key (team_id) references teams (id)
)
```
REPHRASE

The two tables are almost identical, the only differences are that "rosters" references "players" while "staffs" references "managers" and the "role" attribute for staff members: it represents the role inside the team, for instance "General manager", "Coach", "Assistant coach" et cetera.

### Edition
```sql
create table editions (
    id                  int unsigned auto_increment primary key,
    league_id           int unsigned                    not null,
    season_id           int unsigned                    not null,
    number_of_teams     smallint unsigned               null,
    concluded           tinyint(1)                      null,
    winner_id           int unsigned                    null,
    number_of_periods   tinyint unsigned  default '4'   null,
    period_duration     smallint unsigned default '600' null comment 'unit of measure is seconds',
    shot_clock_duration smallint unsigned default '24'  null comment 'unit of measure is seconds',
    overtime_duration   smallint unsigned default '300' null comment 'unit of measure is seconds',
    
    constraint editions_uq
        unique (league_id, season_id),
    constraint editions_leagues_id_fk
        foreign key (league_id) references leagues (id),
    constraint editions_seasons_id_fk
        foreign key (season_id) references seasons (id),
    constraint editions_teams_winner_id_fk
        foreign key (winner_id) references teams (id)
)
```

### Miscellaneous

TODO: draft
TODO: referees
